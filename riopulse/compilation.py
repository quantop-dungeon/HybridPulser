import numpy as np

from typing import Union

from .sequence import Sequence


def translate(seq: Sequence, dt: float = 1e-8) -> list:
    """Produces a set of readable commands for the FPGA state machine.

    Args:
        seq: 
            A pulse sequence.
        dt: 
            Clock period (s).

    Returns:
        A list of commands and their arguments of the format 
        [..., [cmd, arg1, arg2], ...], 
        where cmd is a string and args are integers.
    """

    # Makes a combned list of state switch times for all channels and
    # a list of channel numbers in which the switches occurred.
    times = []
    channel_numbers = []
    for i, c in enumerate(seq.channels):
        times += c.switch_times
        channel_numbers += [i]*len(c.switch_times)

    # Sorts in the order of incresing time.
    sidx = np.argsort(times)
    times = [times[i] for i in sidx]
    channel_numbers = [channel_numbers[i] for i in sidx]

    # Converts switch times to numbers of clock cycles.
    t0 = seq.start_time
    clock_cycles = [round((t-t0)/dt) for t in times]

    commands = []

    # Adds a command to wait for a trigger to start the sequence.
    commands.append(['trigwait', 0, 0])

    # The outputs start in the default state.
    sig = 0b0
    for i, c in enumerate(seq.channels):
        sig = sig | (c.default << i)

    cc = 0
    for ch, cc_next in zip(channel_numbers, clock_cycles):
        if cc_next > cc:

            # Adds a continuous output of sig for (cc_next-cc) clock cycles
            # and moves to the clock cycle of the next switch.
            commands.append(['cout', sig, cc_next-cc-1])
            cc = cc_next

        # Accumulates the changes of outputs over the current clock cycle.
        sig = flip_bit(sig, ch)

    cc_next = round((seq.stop_time - seq.start_time)/dt)
    if cc_next-cc > 1:
        commands.append(['cout', sig, cc_next-cc-1])

    # Returns to the beginning of the instruction list.
    commands.append(['init', 0, 0])

    return commands


def compile_(data: Union[Sequence, list]) -> list:
    """Produces state machine code (a list of 64-bit integers) from 
    a Sequence or a list of readable state machine commands. Readable commands
    generated by the translate method.
    """

    command_no = {'init': 0, 'cout': 1, 'trigwait': 2}

    if isinstance(data, Sequence):
        commands = translate(data)
    else:
        commands = data

    # Each element of the array is an integer of the format: 
    # command number (8 bits), arg1 (8 bits), arg2 (48 bits)
    mcode = []
    for cmd in commands:
        n = command_no[cmd[0]]
        arg1 = cmd[1]
        arg2 = cmd[2]

        mcode.append((n << 56) + (arg1 << 48) + arg2)

    return mcode


def flip_bit(value, bit):
    return value ^ (1 << bit)
